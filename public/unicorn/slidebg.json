{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.21,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0.30196078431372547, 0, 1); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.30196078431372547, 0, 1); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.30195824796997206, 0.38282385447034395) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[{"min":992,"name":"Desktop","max":null,"props":{"noiseType":"4","animating":true}},{"props":{"noiseType":"1","animating":false},"name":"Mobile","min":0,"max":575}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"dither","usesPingPong":false,"speed":0,"texture":false,"parentLayer":"e503ad82-77c5-4b5c-b22c-ff8010fac1d7","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBlueNoise;uniform int uType; uniform float uTime;uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }const int MAX_LEVEL = 4; const float PI2 = 6.28318530718;float getBayerFromCoordLevelScaled(vec2 pixelpos, float scale) { float finalBayer = 0.0; float finalDivisor = 0.0; float layerMult = 1.0;for(float bayerLevel = float(MAX_LEVEL); bayerLevel >= 1.0; bayerLevel--) { float bayerSize = exp2(bayerLevel) * 0.5 / scale; vec2 bayercoord = mod(floor(pixelpos.xy / bayerSize), 2.0); layerMult *= 4.0;float byxx2 = bayercoord.x * 2.0;finalBayer += mix(byxx2, 3.0 - byxx2, bayercoord.y) / 3.0 * layerMult; finalDivisor += layerMult; }return (finalBayer / finalDivisor - 0.006); }float getBlueNoise(vec2 st, float delta, float size) { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution/size)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); return mod((blueNoise.r - 0.5) * PI2 + (delta * (1.0 / PI2)), PI2) / PI2 - 0.005; }float getBayerNoise(vec2 st, float delta, float scale) { vec2 center = uResolution * 0.5; vec2 centered = st * uResolution - center; vec2 offset = vec2( mod(delta * 0.618033988749895, 16.0), mod(delta * 0.381966011250105, 16.0) ) * 20.; vec2 final = (centered + center + offset); return getBayerFromCoordLevelScaled(final, scale); }float getRandNoise(vec2 st, vec2 offset) { return randFibo(st + offset) - 0.005; }float getIGNNoise(vec2 st, float delta, float scale) { float patternSize = max(0.01, scale); vec2 pixelCoords = st * uResolution / patternSize; float frame = mod(delta, 8.0); if(mod(frame, 4.0) >= 2.0) pixelCoords = vec2(-pixelCoords.y, pixelCoords.x); if(mod(frame, 2.0) >= 1.0) pixelCoords.x = -pixelCoords.x; return fract(pixelCoords.x * 0.7548776662 + pixelCoords.y * 0.56984029 + frame * 0.41421356) - 0.005; }vec3 dither(vec3 color, vec2 st) { float delta = floor(uTime); vec2 offset = vec2(randFibo(vec2(123,16) + delta), randFibo(vec2(56,96) + delta)); float noise = 0.0; switch(uType) { case 0: noise = getBlueNoise(st, delta, 2.); break; case 1: noise = getBayerNoise(st, delta, 0.5); break; case 2: noise = getRandNoise(st, offset); break; case 3: noise = getBayerNoise(st, delta, 1.); break; case 4: noise = getBayerNoise(st, delta, 0.25); break; case 5: noise = getBlueNoise(st, delta, 4.); break; case 6: noise = getBlueNoise(st, delta, 1.); break; case 7: noise = getIGNNoise(st, delta, 0.5); break; default: noise = 0.0; } float dither_threshold = max(0.0001, 1.0000); float num_levels = 1.0 / dither_threshold; return floor(color * num_levels + noise) / num_levels; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float delta = floor(uTime); vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }color.rgb = mix(color.rgb, dither(color.rgb, vTextureCoord), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"noiseType":{"name":"uType","type":"1i","value":0}},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect1"},{"breakpoints":[{"props":{"animating":false,"speed":0.5},"max":null,"name":"Desktop","min":992},{"name":"Tablet","min":576,"props":{"animating":true},"max":991},{"max":575,"min":0,"name":"Mobile","props":{"animating":true,"speed":0.1}}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noiseBlur","usesPingPong":false,"speed":0.5,"texture":false,"parentLayer":"44c39084-bfa1-43e5-be72-57b8ae619b1f","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }const int MAX_ITERATIONS = 32; const float MAX_ITERATIONS_F = 32.0; const float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 noiseUv = rot(-0.1134 * -1. * 2.0 * PI) * (uv * vec2(aspectRatio, 1.) - vec2(0.5, 0.5) * vec2(aspectRatio, 1.)) * vec2(0.5000, 1.-0.5000) * 5. * 0.6200; vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.3400 * 2.)); vec2 noiseOffset = (noise.xy - 0.5) * (0.0600 + 0.01) * 0.25; vec4 color = vec4(0.0); for (int i = 0; i < MAX_ITERATIONS; i++) { float offset = float(i) - HALF_ITERATIONS; vec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F); color += texture(uTexture, st); } color /= MAX_ITERATIONS_F; fragColor = color;}","#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }const int MAX_ITERATIONS = 32; const float MAX_ITERATIONS_F = 32.0; const float HALF_ITERATIONS = 16.0;out vec4 fragColor;const float PI = 3.14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 noiseUv = rot(-0.1134 * -1. * 2.0 * PI) * (uv * vec2(aspectRatio, 1.) - vec2(0.5, 0.5) * vec2(aspectRatio, 1.)) * vec2(0.5000, 1.-0.5000) * 5. * 0.6200; vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(noiseUv, uTime * 0.025 + 0.3400 * 2.)); vec2 noiseOffset = (noise.xy - 0.5) * (0.0600 + 0.01) * 0.25; vec4 color = vec4(0.0); for (int i = 0; i < MAX_ITERATIONS; i++) { float offset = float(i) - HALF_ITERATIONS; vec2 st = uv + noiseOffset * (offset / MAX_ITERATIONS_F); color += texture(uTexture, st); } color /= MAX_ITERATIONS_F; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.5}]},"id":"effect2"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","userDownsample":1,"isElement":true,"opacity":0.81,"effects":["edb1e333-ce4e-4542-9b50-a539e354ad84","44c39084-bfa1-43e5-be72-57b8ae619b1f","02f25801-faee-4c1b-a62b-f0868c876bb2","696c0262-3df2-43b7-84f2-14c1b207b8dc","e503ad82-77c5-4b5c-b22c-ff8010fac1d7"],"displace":0,"trackMouse":0,"anchorPoint":"topLeft","mouseMomentum":0,"blendMode":"SCREEN","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"text","justCreated":false,"isSafari":false,"width":725,"widthMode":"fixed","height":543,"heightMode":"fixed","left":0.5085546316165952,"leftMode":"relative","top":0.3564814814814815,"topMode":"relative","rotation":0,"trackAxes":"xy","fontSize":720,"lineHeight":271.5,"letterSpacing":0,"fontFamily":"Heal The Web B Regular","fontStyle":"regular","fontWeight":"400","textAlign":"left","textContent":"🌐\n","fill":["#433D8A"],"gradientAngle":0,"gradientType":"linear","fontSizeMode":"fixed","noTextAsHtml":false,"fontCSS":{"src":"https://assets.unicorn.studio/fonts/custom/GQqkGlDuxlToWqJ1YqRw4qfodgm1/Heal The Web B Regular/Heal The Web B Regular.otf","family":"Heal The Web B Regular"},"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 0.8100); } } fragColor = color; return; }if (4 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(4, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 0.8100); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 0.8100); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"text","windowWidth":1920},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_strip","usesPingPong":false,"speed":0.5,"trackMouseMove":0,"mouseMomentum":0,"trackMouse":0,"texture":false,"parentLayer":"edb1e333-ce4e-4542-9b50-a539e354ad84","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize; float customTexAspect;const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }vec3 getAdjustedP(vec3 p) { vec2 twist = vec2(0, 0);p.xy *= vec2(uResolution.x / uResolution.y, 1);p *= (1. + (0.4500 + 0.01) * 0.5);vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000); vec2 axis = vec2(-1. * vec3(0.55, 0.55, 0.55).y - 1. + mousePos.y/PI, vec3(0.55, 0.55, 0.55).x + mousePos.x/PI) * 2.;float baseTime = uTime * 0.02;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.55, 0.55, 0.55).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;p = combinedRotation * p; p = mix(p, twistY(p, -1.0 * twist.y), step(0.0, abs(twist.y))); p = mix(p, twistX(p, -1.0 * twist.x), step(0.0, abs(twist.x)));return p; }float sdfBox(vec3 p, vec3 b) { vec3 d = abs(p) - b; return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); }float sdfStrip(vec3 p) { vec3 origP = p; p *= ROT_Z_90; p *= ROT_Y_90;float frequency = 0.3800 * 10.0; float amplitude = 0.5000 * 1.;float wave1 = sin(origP.x * frequency + uTime * 0.05) * amplitude; float wave2 = cos((origP.x + 0.2300) * frequency * 0.75 + uTime * 0.075) * amplitude; float wave3 = cos((p.x + 0.2300) * frequency * 0.75 + uTime * 0.075) * amplitude; p.x += (wave1 + wave2) * 0.2; p.y += (wave3) * 0.3; float d = sdfBox(p, vec3(0.2600 * 0.1, 20., 0.1700)); return d; }float getMergedSDF(vec3 p) { return sdfStrip(getAdjustedP(p)); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float NdotV = abs(dot(eyeVector, worldNormal)); float width = fwidth(dot(eyeVector, worldNormal)); float threshold = 0.2; float edgeDampFactor = smoothstep(threshold, -threshold, width); float fresnelFactor = 1.0 - NdotV; return pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 0.3400 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.3400 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.4200 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);vec2 rayDirOffset = vec2( rand(rd.xy + step) - 0.5, rand(rd.xy + step + 2.) - 0.5 ) * 0.5; refractedRayR.xy += rayDirOffset * (0.1 + disp.r) * 0.8500; refractedRayG.xy += rayDirOffset * (0.1 + disp.g) * 0.8500; refractedRayB.xy += rayDirOffset * (0.1 + disp.b) * 0.8500;refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float eps) { const vec3 k0 = vec3(1.0, -1.0, -1.0); const vec3 k1 = vec3(-1.0, -1.0, 1.0); const vec3 k2 = vec3(-1.0, 1.0, -1.0); const vec3 k3 = vec3(1.0, 1.0, 1.0); return normalize( k0 * getMergedSDF(p + k0 * eps) + k1 * getMergedSDF(p + k1 * eps) + k2 * getMergedSDF(p + k2 * eps) + k3 * getMergedSDF(p + k3 * eps) ); }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);return frostOrDispersion(rd, normal); return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0.0000000001, getMergedSDF(p) - (0.4500 * 0.5 + 0.01)); }const int STEPS = 128; const float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) { float pixelSize = 0.005; float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0;for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float progress = float(i)/float(STEPS); float step = distance * mix(1., 2., progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize * 0.5); break; }traveled += max(step, pixelSize); if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return texture(uTexture, vTextureCoord); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 0.0000); vec3 refractionColor = sampleTexture(samplePosition, entryNormal); vec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000);vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5400 * vec3(1, 1, 1);vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.2200 + 0.01); vec3 specularEffect = specFactor * 0.2200 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000); finalColor += combinedEffects;vec4 outputColor = mix(bg, vec4(finalColor, 1.), partialAlpha);return outputColor; }out vec4 fragColor;void main() { vec4 col = vec4(0);if(0.1700 <= 0.0001) { col = vec4(0); if(1 == 1) { col = texture(uTexture, vTextureCoord); } fragColor = col; return; }vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5); col = rayMarch(viewDir, rd); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[{"min":992,"max":null,"props":{"animating":false,"turbulence":0.5,"speed":0.25,"phase":0,"frequency":0.2},"name":"Desktop"},{"max":575,"min":0,"name":"Mobile","props":{"animating":true,"turbulence":0.42,"phase":0.34,"frequency":0.39,"speed":0.14}}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noise","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"696c0262-3df2-43b7-84f2-14c1b207b8dc","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform float uPhase; uniform float uFrequency; uniform float uTurbulence; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec2 getPerlinNoise(vec2 uv, vec2 textureCoord) { vec2 skew = vec2(0.5000, 1. - 0.5000); float noiseX = perlin_noise(vec3( uv * skew, uPhase + uTime * 0.03 ));float noiseY = perlin_noise(vec3( (uv + vec2(4.37)) * skew, uPhase + uTime * 0.03 ));vec2 offset = vec2(noiseX * 1.5, noiseY * 1.5) * 0.5 + 0.5;return mix(textureCoord, offset, uTurbulence * 1.2); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { return getPerlinNoise(uv, textureCoord); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); vec2 drift = vec2(0, 0.0000 * uTime * 0.0125); pos += drift * rot(0.3591 * -2. * PI); vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * uFrequency; st = rot(0.3591 * -2. * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"turbulence":{"name":"uTurbulence","type":"1f","value":0.5},"phase":{"name":"uPhase","type":"1f","value":0},"frequency":{"name":"uFrequency","type":"1f","value":0.2}},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"retro_screen","usesPingPong":false,"speed":0.82,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 gammaCorrect(vec3 color, float gamma) { return pow(color, vec3(1.0 / gamma)); }vec3 styleThree(vec2 curvedUV) { float cellPadding = 0.0; float pixelHeight = 1.5;float aspectRatio = uResolution.x / uResolution.y; float aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float size = max(3.0 / 1080.0, 0.015 * (1.0 - 0.6120)); vec2 cellSize = vec2(size * 0.75 / aspectRatio, size * 1.75) * aspectCorrection; cellSize = floor(cellSize * vec2(1080)) / vec2(1080);vec2 staggeredUV = curvedUV; if (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) { staggeredUV.y += 0.5 * cellSize.y; }vec2 cellCoords = floor(staggeredUV / cellSize) * cellSize;vec2 unstaggerOffset = vec2(0.0); if (mod(floor(curvedUV.x / cellSize.x), 2.0) > 0.5) { unstaggerOffset.y = -0.5 * cellSize.y; }vec2 sampleCoord = cellCoords + 0.5 * cellSize + unstaggerOffset; vec2 cellPos = mod(staggeredUV, cellSize) / cellSize;vec3 finalColor = vec3(0.0); vec3 blurColor = vec3(0.0); float blurFactor = 1.0 / 9.0; for (int dx = -1; dx <= 1; dx++) { for (int dy = -1; dy <= 1; dy++) { vec2 offset = vec2(float(dx), dy) * cellSize * 0.4200; blurColor += texture(uTexture, sampleCoord + offset).rgb * blurFactor; } }float distFromCenter = length(cellPos - 0.5); float noise = random(curvedUV); float pixelFactor = smoothstep(pixelHeight * 0.666, 0.0, distFromCenter + noise * 0.05);vec3 gradientColor = vec3(0.0); gradientColor.r = smoothstep(0.0, 0.5, cellPos.y) * smoothstep(1.0, 0.5, cellPos.y); gradientColor.g = smoothstep(0.25, 0.75, cellPos.y) * smoothstep(1.5, 0.5, cellPos.y); gradientColor.b = smoothstep(0.5, 1.0, cellPos.y) * smoothstep(1.5, 1.0, cellPos.y);gradientColor *= vec3(0.9, 1.1, 2.2);finalColor = mix(blurColor, gradientColor * blurColor, 0.4) * pixelFactor * 1.5; finalColor = floor(finalColor * 32.0000) / 32.0000; finalColor = gammaCorrect(finalColor, 3.0 * 0.4200);float flicker = 1.0 + 0.03 * cos(sampleCoord.x / 60.0 + uTime * 20.0); finalColor *= mix(1.0, flicker, 0.0000);return finalColor; }void main() { vec3 finalColor;vec4 color = texture(uTexture, vTextureCoord);if(color.a <= 0.001) { fragColor = vec4(0); return; }finalColor = styleThree(vTextureCoord);vec4 bg = texture(uTexture, vTextureCoord);vec4 col = mix(bg, vec4(finalColor, bg.a), 0.3300); fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[{"name":"Desktop","max":null,"props":{"animating":false,"frequency":0.2,"turbulence":0.5},"min":992},{"max":575,"min":0,"props":{"animating":true,"frequency":1,"turbulence":1},"name":"Mobile"}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noise","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"02f25801-faee-4c1b-a62b-f0868c876bb2","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform float uTime; uniform float uFrequency; uniform float uTurbulence; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); }vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0)); float index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0; cuboct.y *= 1.0 - index1; cuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec2 get2sNoise(vec2 uv, vec2 textureCoord) { vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(uv * vec2(0.5000, 1. - 0.5000) * 0.7, 0.0000 + uTime*0.02)); vec2 offset = noise.xy/7. + 0.5; return mix(textureCoord, offset, uTurbulence); }vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) { return get2sNoise(uv, textureCoord); }void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); vec2 drift = vec2(0, 0.0000 * uTime * 0.0125); pos += drift * rot(0.1269 * -2. * PI); vec2 st = (uv - pos) * vec2(aspectRatio, 1); st *= 12. * uFrequency; st = rot(0.1269 * -2. * PI) * st;vec2 noise = getNoiseOffset(st, uv); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));if (0 == 1) { dist = max(0., (0.5 - dist)); }uv = mix(uv, noise, dist); vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"frequency":{"name":"uFrequency","type":"1f","value":0.2},"turbulence":{"name":"uTurbulence","type":"1f","value":0.5}},"isBackground":false},"id":"effect6"}],"options":{"name":"Effect stack","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":true},"version":"1.4.33","id":"JugkPnLWvt6WBdvfURvF"}